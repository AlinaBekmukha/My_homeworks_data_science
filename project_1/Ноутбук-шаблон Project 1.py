#!/usr/bin/env python
# coding: utf-8

# <center> <img src = https://raw.githubusercontent.com/AndreyRysistov/DatasetsForPandas/main/hh%20label.jpg alt="drawing" style="width:400px;">

# # <center> Проект: Анализ вакансий на hh.ru
#    

# In[189]:


import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px


# # Исследование структуры данных

# 1. Прочитайте данные с помощью библиотеки Pandas. Совет: перед чтением обратите внимание на разделитель внутри файла. 

# In[190]:


headhunter_data = pd.read_csv('data/dst-3.0_16_1_hh_database.csv', sep=';')


# 2. Выведите несколько первых (последних) строк таблицы, чтобы убедиться в том, что ваши данные не повреждены. Ознакомьтесь с признаками и их структурой.

# In[191]:


display(headhunter_data)


# 3. Выведите основную информацию о числе непустых значений в столбцах и их типах в таблице.

# 4. Обратите внимание на информацию о числе непустых значений.

# In[192]:


headhunter_data.info()


# 5. Выведите основную статистическую информацию о столбцах.
# 

# In[193]:


headhunter_data.describe(include=['object'])


# # Преобразование данных

# 1. Начнем с простого - с признака **"Образование и ВУЗ"**. Его текущий формат это: **<Уровень образования год выпуска ВУЗ специальность...>**. Например:
# * Высшее образование 2016 Московский авиационный институт (национальный исследовательский университет)...
# * Неоконченное высшее образование 2000  Балтийская государственная академия рыбопромыслового флота…
# Нас будет интересовать только уровень образования.
# 
# Создайте с помощью функции-преобразования новый признак **"Образование"**, который должен иметь 4 категории: "высшее", "неоконченное высшее", "среднее специальное" и "среднее".
# 
# Выполните преобразование, ответьте на контрольные вопросы и удалите признак "Образование и ВУЗ".
# 
# Совет: обратите внимание на структуру текста в столбце **"Образование и ВУЗ"**. Гарантируется, что текущий уровень образования соискателя всегда находится в первых 2ух слов и начинается с заглавной буквы. Воспользуйтесь этим.
# 
# *Совет: проверяйте полученные категории, например, с помощью метода unique()*
# 

# In[194]:


def get_level_of_education(level):
    level = ' '.join(level.split(' ')[:3])
    if 'Высшее' in level:
        return 'высшее'
    elif 'Неоконченное высшее' in level:
        return 'неоконченное высшее'
    elif 'Среднее специальное' in level:
        return 'среднее специальное'
    elif 'Среднее образование' in level:
        return 'среднее'

headhunter_data['Уровень образования'] = headhunter_data['Образование и ВУЗ'].apply(get_level_of_education)
display(headhunter_data['Уровень образования'])


# In[195]:


# Сколько соискателей имеет средний уровень образования (школьное образование)?
print(headhunter_data['Уровень образования'].value_counts())


# In[196]:


# Удаляю признак "Образование и ВУЗ"
headhunter_data = headhunter_data.drop('Образование и ВУЗ', axis=1)
display(headhunter_data.head())


# 2. Теперь нас интересует столбец **"Пол, возраст"**. Сейчас он представлен в формате **<Пол , возраст , дата рождения >**. Например:
# * Мужчина , 39 лет , родился 27 ноября 1979 
# * Женщина , 21 год , родилась 13 января 2000
# Как вы понимаете, нам необходимо выделить каждый параметр в отдельный столбец.
# 
# Создайте два новых признака **"Пол"** и **"Возраст"**. При этом важно учесть:
# * Признак пола должен иметь 2 уникальных строковых значения: 'М' - мужчина, 'Ж' - женщина. 
# * Признак возраста должен быть представлен целыми числами.
# 
# Выполните преобразование, ответьте на контрольные вопросы и удалите признак **"Пол, возраст"** из таблицы.
# 
# *Совет: обратите внимание на структуру текста в столбце, в части на то, как разделены параметры пола, возраста и даты рождения между собой - символом ' , '. 
# Гарантируется, что структура одинакова для всех строк в таблице. Вы можете воспользоваться этим.*
# 

# In[197]:


def get_gender(arg):
    if 'Мужчина' in arg:
        return 'М'
    else:
        return 'Ж'
    
def get_age(arg):
    arg_splitted = arg.split(' ')
    year_words = ['год', 'года', 'лет']
    for index, item in enumerate(arg_splitted):
        if item in year_words:
            return int(arg_splitted[index-1])
        
headhunter_data['Возраст'] = headhunter_data['Пол, возраст'].apply(get_age)
headhunter_data['Пол'] = headhunter_data['Пол, возраст'].apply(get_gender)

headhunter_data = headhunter_data.drop('Пол, возраст', axis=1)
display(headhunter_data.head())


# In[198]:


# Сколько процентов женских резюме представлено в наших данных? Ответ округлите до сотых.
print(round(headhunter_data['Пол'].value_counts(normalize=True)['Ж']*100, 2))

# Чему равен средний возраст соискателей? Ответ округлите до десятых.
print(round(headhunter_data['Возраст'].mean(),2))


# 3. Следующим этапом преобразуем признак **"Опыт работы"**. Его текущий формат - это: **<Опыт работы: n лет m месяцев, периоды работы в различных компаниях…>**. 
# 
# Из столбца нам необходимо выделить общий опыт работы соискателя в месяцах, новый признак назовем "Опыт работы (месяц)"
# 
# Для начала обсудим условия решения задачи:
# * Во-первых, в данном признаке есть пропуски. Условимся, что если мы встречаем пропуск, оставляем его как есть (функция-преобразование возвращает NaN)
# * Во-вторых, в данном признаке есть скрытые пропуски. Для некоторых соискателей в столбце стоит значения "Не указано". Их тоже обозначим как NaN (функция-преобразование возвращает NaN)
# * В-третьих, нас не интересует информация, которая описывается после указания опыта работы (периоды работы в различных компаниях)
# * В-четвертых, у нас есть проблема: опыт работы может быть представлен только в годах или только месяцах. Например, можно встретить следующие варианты:
#     * Опыт работы 3 года 2 месяца…
#     * Опыт работы 4 года…
#     * Опыт работы 11 месяцев…
#     * Учитывайте эту особенность в вашем коде
# 
# Учитывайте эту особенность в вашем коде
# 
# В результате преобразования у вас должен получиться столбец, содержащий информацию о том, сколько месяцев проработал соискатель.
# Выполните преобразование, ответьте на контрольные вопросы и удалите столбец **"Опыт работы"** из таблицы.
# 

# In[199]:


def get_experience(arg):
    if arg is np.nan or arg == 'Не указано':
        return None
    year_words=['год', 'года', 'лет']
    month_words=['месяц', 'месяца', 'месяцев']
    arg_splitted = arg.split(' ')[:7]
    years = 0
    months = 0
    for index, item in enumerate (arg_splitted):
        if item in year_words:
            years = int(arg_splitted[index-1])
        if item in month_words:
            months = int(arg_splitted[index-1])
    return int(years*12 + months)

headhunter_data['Месяцы работы'] = headhunter_data['Опыт работы'].apply(get_experience)

headhunter_data = headhunter_data.drop('Опыт работы', axis=1)
display(headhunter_data.head())


# In[200]:


# Чему равен медианный опыт работы (в месяцах) в нашей таблице?
print(headhunter_data['Месяцы работы'].median())


# 4. Хорошо идем! Следующий на очереди признак "Город, переезд, командировки". Информация в нем представлена в следующем виде: **<Город , (метро) , готовность к переезду (города для переезда) , готовность к командировкам>**. В скобках указаны необязательные параметры строки. Например, можно встретить следующие варианты:
# 
# * Москва , не готов к переезду , готов к командировкам
# * Москва , м. Беломорская , не готов к переезду, не готов к командировкам
# * Воронеж , готов к переезду (Сочи, Москва, Санкт-Петербург) , готов к командировкам
# 
# Создадим отдельные признаки **"Город"**, **"Готовность к переезду"**, **"Готовность к командировкам"**. При этом важно учесть:
# 
# * Признак **"Город"** должен содержать только 4 категории: "Москва", "Санкт-Петербург" и "город-миллионник" (их список ниже), остальные обозначьте как "другие".
# 
#     Список городов-миллионников:
#     
#    <code>million_cities = ['Новосибирск', 'Екатеринбург','Нижний Новгород','Казань', 'Челябинск','Омск', 'Самара', 'Ростов-на-Дону', 'Уфа', 'Красноярск', 'Пермь', 'Воронеж','Волгоград']
#     </code>
#     Инфорация о метро, рядом с которым проживает соискатель нас не интересует.
# * Признак **"Готовность к переезду"** должен иметь два возможных варианта: True или False. Обратите внимание, что возможны несколько вариантов описания готовности к переезду в признаке "Город, переезд, командировки". Например:
#     * … , готов к переезду , …
#     * … , не готова к переезду , …
#     * … , готова к переезду (Москва, Санкт-Петербург, Ростов-на-Дону)
#     * … , хочу переехать (США) , …
#     
#     Нас интересует только сам факт возможности или желания переезда.
# * Признак **"Готовность к командировкам"** должен иметь два возможных варианта: True или False. Обратите внимание, что возможны несколько вариантов описания готовности к командировкам в признаке "Город, переезд, командировки". Например:
#     * … , готов к командировкам , … 
#     * … , готова к редким командировкам , …
#     * … , не готов к командировкам , …
#     
#     Нас интересует только сам факт готовности к командировке.
#     
#     Еще один важный факт: при выгрузки данных у некоторых соискателей "потерялась" информация о готовности к командировкам. Давайте по умолчанию будем считать, что такие соискатели не готовы к командировкам.
#     
# Выполните преобразования и удалите столбец **"Город, переезд, командировки"** из таблицы.
# 
# *Совет: обратите внимание на то, что структура текста может меняться в зависимости от указания ближайшего метро. Учите это, если будете использовать порядок слов в своей программе.*
# 

# In[201]:


def current_city(x):
    x_split = x.split(' , ')[0]
    million_cities = ['Новосибирск', 'Екатеринбург', 'Нижний Новгород', 'Казань',
                  'Челябинск', 'Омск', 'Самара', 'Ростов-на-Дону', 'Уфа',
                  'Красноярск', 'Пермь', 'Воронеж', 'Волгоград']
    default_city = ['Москва', 'Санкт-Петербург']
    if x_split in million_cities:
        return 'город-миллионник'
    elif x_split in default_city:
        return x_split
    else:
        return 'другие'
    
headhunter_data['Город'] = headhunter_data['Город, переезд, командировки'].apply(current_city)


def get_ready_to_move(arg):
    if 'не готова к переезду' in arg or 'не готов к переезду' in arg:
        return False
    elif 'хочу' in arg:
        return True
    else:
        return True

headhunter_data['Готовность к переезду'] = headhunter_data['Город, переезд, командировки'].apply(get_ready_to_move)

def get_ready_for_bisiness_trips(arg):
    if ('командировка' in arg):
        if ('не готов к командировкам' in arg) or('не готова к командировкам' in arg):
            return False
        else: 
            return True
    else:
        return False

headhunter_data['Готовность к командировкам'] = headhunter_data['Город, переезд, командировки'].apply(get_ready_for_bisiness_trips)

headhunter_data = headhunter_data.drop('Город, переезд, командировки', axis=1)
display(headhunter_data.head())


# In[202]:


# Сколько процентов соискателей живут в Санкт-Петербурге? Ответ округлите до целого.
round(headhunter_data['Город'].value_counts(normalize=True)*100)


# In[203]:


print(round(headhunter_data[
    headhunter_data['Готовность к переезду'] & headhunter_data['Готовность к командировкам'
                                                                 ]].shape[0] / headhunter_data.shape[0]*100))


# 5. Рассмотрим поближе признаки **"Занятость"** и **"График"**. Сейчас признаки представляют собой набор категорий желаемой занятости (полная занятость, частичная занятость, проектная работа, волонтерство, стажировка) и желаемого графика работы (полный день, сменный график, гибкий график, удаленная работа, вахтовый метод).
# На сайте hh.ru соискатель может указывать различные комбинации данных категорий, например:
# * полная занятость, частичная занятость
# * частичная занятость, проектная работа, волонтерство
# * полный день, удаленная работа
# * вахтовый метод, гибкий график, удаленная работа, полная занятость
# 
# Такой вариант признаков имеет множество различных комбинаций, а значит множество уникальных значений, что мешает анализу. Нужно это исправить!
# 
# Давайте создадим признаки-мигалки для каждой категории: если категория присутствует в списке желаемых соискателем, то в столбце на месте строки рассматриваемого соискателя ставится True, иначе - False.
# 
# Такой метод преобразования категориальных признаков называется One Hot Encoding и его схема представлена на рисунке ниже:
# <img src=https://raw.githubusercontent.com/AndreyRysistov/DatasetsForPandas/main/ohe.jpg>
# Выполните данное преобразование для признаков "Занятость" и "График", ответьте на контрольные вопросы, после чего удалите их из таблицы

# In[204]:


employments = ['полная занятость', 'частичная занятость', 'проектная работа', 'волонтерство', 'стажировка']
charts = ['полный день', 'сменный график', 
         'гибкий график', 'удаленная работа',
         'вахтовый метод']

for employment, chart in zip(employments, charts):
    
    headhunter_data[employment] = headhunter_data['Занятость'].apply(lambda x: employment in x)
    headhunter_data[chart] = headhunter_data['График'].apply(lambda x: chart in x)
    
headhunter_data = headhunter_data.drop('Занятость', axis=1)
headhunter_data = headhunter_data.drop('График', axis=1)


# In[205]:


print(headhunter_data[headhunter_data['проектная работа'] & headhunter_data['волонтерство']].shape[0])
print(headhunter_data[headhunter_data['вахтовый метод'] & headhunter_data['гибкий график']].shape[0])


# 6. (2 балла) Наконец, мы добрались до самого главного и самого важного - признака заработной платы **"ЗП"**. 
# В чем наша беда? В том, что помимо желаемой заработной платы соискатель указывает валюту, в которой он бы хотел ее получать, например:
# * 30000 руб.
# * 50000 грн.
# * 550 USD
# 
# Нам бы хотелось видеть заработную плату в единой валюте, например, в рублях. Возникает вопрос, а где взять курс валют по отношению к рублю?
# 
# На самом деле язык Python имеет в арсенале огромное количество возможностей получения данной информации, от обращения к API Центробанка, до использования специальных библиотек, например pycbrf. Однако, это не тема нашего проекта.
# 
# Поэтому мы пойдем в лоб: обратимся к специальным интернет-ресурсам для получения данных о курсе в виде текстовых файлов. Например, MDF.RU, данный ресурс позволяет удобно экспортировать данные о курсах различных валют и акций за указанные периоды в виде csv файлов. Мы уже сделали выгрузку курсов валют, которые встречаются в наших данных за период с 29.12.2017 по 05.12.2019. Скачать ее вы можете **на платформе**
# 
# Создайте новый DataFrame из полученного файла. В полученной таблице нас будут интересовать столбцы:
# * "currency" - наименование валюты в ISO кодировке,
# * "date" - дата, 
# * "proportion" - пропорция, 
# * "close" - цена закрытия (последний зафиксированный курс валюты на указанный день).
# 
# 
# Перед вами таблица соответствия наименований иностранных валют в наших данных и их общепринятых сокращений, которые представлены в нашем файле с курсами валют. Пропорция - это число, за сколько единиц валюты указан курс в таблице с курсами. Например, для казахстанского тенге курс на 20.08.2019 составляет 17.197 руб. за 100 тенге, тогда итоговый курс равен - 17.197 / 100 = 0.17197 руб за 1 тенге.
# Воспользуйтесь этой информацией в ваших преобразованиях.
# 
# <img src=https://raw.githubusercontent.com/AndreyRysistov/DatasetsForPandas/main/table.jpg>
# 
# 
# Осталось только понять, откуда брать дату, по которой определяется курс? А вот же она - в признаке **"Обновление резюме"**, в нем содержится дата и время, когда соискатель выложил текущий вариант своего резюме. Нас интересует только дата, по ней бы и будем сопоставлять курсы валют.
# 
# Теперь у нас есть вся необходимая информация для того, чтобы создать признак "ЗП (руб)" - заработная плата в рублях.
# 
# После ответа на контрольные вопросы удалите исходный столбец заработной платы "ЗП" и все промежуточные столбцы, если вы их создавали.

# Итак, давайте обсудим возможный алгоритм преобразования: 
# 1. Перевести признак "Обновление резюме" из таблицы с резюме в формат datetime и достать из него дату. В тот же формат привести признак "date" из таблицы с валютами.
# 2. Выделить из столбца "ЗП" сумму желаемой заработной платы и наименование валюты, в которой она исчисляется. Наименование валюты перевести в стандарт ISO согласно с таблицей выше.
# 3. Присоединить к таблице с резюме таблицу с курсами по столбцам с датой и названием валюты (подумайте, какой тип объединения надо выбрать, чтобы в таблице с резюме сохранились данные о заработной плате, изначально представленной в рублях). Значение close для рубля заполнить единицей 1 (курс рубля самого к себе)
# 4. Умножить сумму желаемой заработной платы на присоединенный курс валюты (close) и разделить на пропорцию (обратите внимание на пропуски после объединения в этих столбцах), результат занести в новый столбец "ЗП (руб)".
# 

# In[206]:


def get_desired_salary(arg):
    salary = float(arg.split(' ')[0])
    return salary

        
def get_currency(arg):
    currency_dict = {
        'USD': 'USD', 'KZT': 'KZT',
        'грн': 'UAH', 'белруб': 'BYN',
        'EUR': 'EUR', 'KGS': 'KGS',
        'сум': 'UZS', 'AZN': 'AZN'
    }
    curr = arg.split(' ')[1].replace('.', '')
    if curr == 'руб':
        return 'RUB'
    else:
        return currency_dict[curr]

headhunter_data['Обновление резюме'] = pd.to_datetime(headhunter_data['Обновление резюме'], dayfirst=True).dt.date # в первоначальном признаке день идет первым
headhunter_data['Сумма желаемой оплаты'] = headhunter_data['ЗП'].apply(get_desired_salary) #или ЗП(tmp)
headhunter_data['Валюта'] = headhunter_data['ЗП'].apply(get_currency) # или Курс (tmp)
display(headhunter_data.head())

exchange_rates_data = pd.read_csv('data/ExchangeRates.csv')
exchange_rates_data['date'] = pd.to_datetime(exchange_rates_data['date'], dayfirst=True).dt.date
display(exchange_rates_data)


# In[207]:


merged_hh_data = headhunter_data.merge(
    exchange_rates_data, 
    left_on=['Валюта', 'Обновление резюме'],
    right_on=['currency', 'date',], 
    how='left'
)
display(merged_hh_data)
# присоединение таблицы с курсами к таблице с резюме по столбцу date


# In[208]:


print('Число строк в таблице headhunter_data: ', headhunter_data.shape[0])
print('Число строк в таблице merged_hh_data: ', merged_hh_data.shape[0])
print(headhunter_data.shape[0] == merged_hh_data.shape[0])


# In[209]:


merged_hh_data['close'] = merged_hh_data['close'].fillna(1)
merged_hh_data['proportion'] = merged_hh_data['proportion'].fillna(1)
display(merged_hh_data)


# In[210]:


headhunter_data['ЗП (руб)'] = merged_hh_data['close'] * merged_hh_data['Сумма желаемой оплаты'] / merged_hh_data['proportion']
headhunter_data = headhunter_data.drop(['Сумма желаемой оплаты', 'Валюта'], axis=1)
print(round(headhunter_data['ЗП (руб)'].median()/1000))
display(headhunter_data)


# # Исследование зависимостей в данных

# 1. Постройте распределение признака **"Возраст"**. Опишите распределение, отвечая на следующие вопросы: чему равна мода распределения, каковы предельные значения признака, в каком примерном интервале находится возраст большинства соискателей? Есть ли аномалии для признака возраста, какие значения вы бы причислили к их числу?
# *Совет: постройте гистограмму и коробчатую диаграмму рядом.*

# In[211]:


figure = px.histogram(
    headhunter_data,
    x = 'Возраст',
    title = 'Распределение возраста соискателей',
    histnorm = 'percent',
    width = 500,
    marginal = 'box'
)
figure.show()

# Чему равно модальное значение возраста соискателей?
headhunter_data['Возраст'].mode()

figure.write_html("data/histogram_age.html")


# **Чему равна мода распределения?**  
# Мода распределения равна 30 годам. Это самый часто встречающийся возраст среди соикателей.  
# **Каковы предельные значения признака, в каком примерном интервале находится возраст большинства соискателей?**  
# Предельные значения признака возраста, минимальное и максимальное, равны 14 и 49 годам, соответственно. В интервале от 27 до 36 лет находится возраст большинства соискателей.  
# **Есть ли аномалии для данного признака? Если есть, то какие значения вы бы причислили к таковым?**  
# Да, для данного признака есть аномалии. Например, возраст соискателей 100 лет. Возраст соискателя 77 лет выглядит ещё реалистично, но вот 100 лет похоже на аномалию.  

# 2. Постройте распределение признака **"Опыт работы (месяц)"**. Опишите данное распределение, отвечая на следующие вопросы: чему равна мода распределения, каковы предельные значения признака, в каком примерном интервале находится опыт работы большинства соискателей? Есть ли аномалии для признака опыта работы, какие значения вы бы причислили к их числу?
# *Совет: постройте гистограмму и коробчатую диаграмму рядом.*

# In[212]:


figure = px.histogram(
    headhunter_data,
    x = 'Месяцы работы',
    title = 'Распределение опыта работы соискателей',
    histnorm = 'percent',
    width = 500,
    marginal = 'box'
)
figure.show()

# Чему равен максимальный опыт работы (в месяцах)?
headhunter_data['Месяцы работы'].max()
headhunter_data['Месяцы работы'].mode()

figure.write_html("data/histogram_work_experience.html")


# **Чему равна мода распределения?**  
# Наиболее часто регистрируемая продолжительность работы равна 81 месяцам или 6 годам и 7,5 месяцам.  
# **Каковы предельные значения признака, в каком примерном интервале находится опыт работы большинства соискателей?**  
# Предельные значения признака это 1 месяц работы и 299 месяцев работы. Опыт работы большинства соискателей находится интревале от 57 до 154 месяцев.  
# **Есть ли аномалии для признака? Если есть, то какие значения вы бы причислили к таковым?**  
# Да, к аномалиям нужно причислить опыт работы 1188 месяцев. 99 лет опыта работы представить (пока что) никак невозможно.

# 3. Постройте распределение признака **"ЗП (руб)"**. Опишите данное распределение, отвечая на следующие вопросы: каковы предельные значения признака, в каком примерном интервале находится заработная плата большинства соискателей? Есть ли аномалии для признака ЗП? Обратите внимание на гигантские размеры желаемой заработной платы.
# *Совет: постройте гистограмму и коробчатую диаграмму рядом.*
# 

# In[213]:


figure = px.histogram(
    data_frame = headhunter_data,
    x = 'ЗП (руб)',
    title = 'Распределение желаемой ЗП (руб) соискателей',
    histnorm = 'percent',
    width = 500,
    marginal = 'box'
)
figure.show()

headhunter_data[headhunter_data['ЗП (руб)'] > 1000000].shape[0]
headhunter_data['ЗП (руб)'].mode()

figure.write_html("data/histogram_salary.html")


# **Чему равна мода распределения?**  
# 50 тысяч рублей является наиболее часто всречающейся зарабатной платой.  
# **Каковы предельные значения признака, в каком примерном интервале находится заработная плата большинства соискателей?**
# 1 и 180K являются предельными занчениями признака. 37К и 95К, в этом интервале находится заработная плата большинства соискателей.  
# **Есть ли аномалии для признака заработной платы? Если есть, то какие значения вы бы причислили к таковым?**
# Я думаю, что заработная плата в 1 рубль и заработная плата больше 1 миллиона рублей может быть причислена к аномалиям.

# 4. Постройте диаграмму, которая показывает зависимость **медианной** желаемой заработной платы (**"ЗП (руб)"**) от уровня образования (**"Образование"**). Используйте для диаграммы данные о резюме, где желаемая заработная плата меньше 1 млн рублей.
# *Сделайте выводы по представленной диаграмме: для каких уровней образования наблюдаются наибольшие и наименьшие уровни желаемой заработной платы? Как вы считаете, важен ли признак уровня образования при прогнозировании заработной платы?*

# In[216]:


bar_data = headhunter_data[headhunter_data['ЗП (руб)'] < 1e6].groupby('Уровень образования',
    as_index=False).median()

fig = px.bar(
    data_frame=bar_data,
    x='Уровень образования',
    y='ЗП (руб)',
    title='Медианная желаемая з/п в зависимости от уровня образования'
)
fig.show()

fig.write_html("data/bar_salary_vs_education.html")


# **Для каких уровней образования наблюдаются наибольшие и наименьшие уровни желаемой заработной платы?**    
# Нибольшиий уровень желаемой оплаты наблюдвается для высшего образования, а наимельшие уровни заработной платы можно видеть для среднего и среднего специального образования.  
# **Как вы считаете, важен ли признак уровня образования при прогнозировании заработной платы?**  
# Да, я думаю, что это важный признак, поскольку с уровнем образования заработная плата вырастает и притязания кандидатов также вырастают.

# 5. Постройте диаграмму, которая показывает распределение желаемой заработной платы (**"ЗП (руб)"**) в зависимости от города (**"Город"**). Используйте для диаграммы данные о резюме, где желая заработная плата меньше 1 млн рублей.
# *Сделайте выводы по полученной диаграмме: как соотносятся медианные уровни желаемой заработной платы и их размах в городах? Как вы считаете, важен ли признак города при прогнозировании заработной платы?*

# In[217]:


box_data = headhunter_data[headhunter_data['ЗП (руб)'] < 1e6]

fig = px.box(
    data_frame=box_data,
    x='Город',
    y='ЗП (руб)',
    title='Медианная желаемая з/п в зависимости от места работы'
)
fig.show()

fig.write_html("data/box_salary_vs_location.html")


# **Как соотносятся медианные уровни желаемой заработной платы и их размах в городах?**  
# Медианный уровень желаемой ЗП в Москве (85К) выше, чем Санкт-Петербурге (60К), также как и размах ЗП (Москва от 60 до 150K, Санкт-Петербург от 45 до 85К). В городах-миллионниках и других городах как медианная желаемая ЗП совпадают (40К), так и размах (от 30 до 60К).  
# **Как вы считаете, важен ли признак города при прогнозировании заработной платы?**
# Да, признак города очень важен. Поскольку с размером города (начеление) заработная плата увеличивается, как рельная, так и жалаемая.

# 6. Постройте **многоуровневую столбчатую диаграмму**, которая показывает зависимость медианной заработной платы (**"ЗП (руб)"**) от признаков **"Готовность к переезду"** и **"Готовность к командировкам"**. Проанализируйте график, сравнив уровень заработной платы в категориях.

# In[218]:


bar_data = headhunter_data.groupby(
    ['Готовность к командировкам', 'Готовность к переезду'],
    as_index=False
)['ЗП (руб)'].median()

fig = px.bar(
    data_frame=bar_data,
    y='Готовность к переезду',
    x='ЗП (руб)',
    barmode="group",
    color='Готовность к командировкам',
    orientation='h',
    title='Медианная з/п по готовности к командировкам/переезду'
)
fig.show()

fig.write_html("data/bar_salary_vs_move_travel.html")


# **Проанализируйте график, сравнив уровень заработной платы в категориях.**  
# Готовность как переездам, так и к командировкам гарантирует увеличение заработной платы. Готовность к командировкам ценится выше, чем готовность в переезду. В общем то, готовность к переезду подразумевает увеличение заработной платы, по сравнению с тем, если человек не готов ни к переезду, ни к командировкам.

# 7. Постройте сводную таблицу, иллюстрирующую зависимость **медианной** желаемой заработной платы от возраста (**"Возраст"**) и образования (**"Образование"**). На полученной сводной таблице постройте **тепловую карту**. Проанализируйте тепловую карту, сравнив показатели внутри групп.

# In[219]:


pivot = headhunter_data.pivot_table(
    index= 'Уровень образования',
    columns= 'Возраст',
    values= 'ЗП (руб)',
    aggfunc='median',
    fill_value = 0
)


fig = px.imshow(
    pivot,
    aspect = 'auto',
    color_continuous_scale = 'greens',
    title='Зависимость заработной платы от возраста и образования'
)
fig.show()

figure.write_html("data/heatmap_salary_vs_age_education.html")


# **Проанализируйте тепловую карту, сравнив показатели внутри групп.**  
# Высшее образование более или менее гарантирует учеличение заработной платы с возрастом.  
# Неоконченное высшее образование также показывает постепенное увеличение желаемой заработной платы, однако возраст соискателей значительно снижается по сравнению с сискателями, имеющими высшее образование.  
# И при среднем образовании и при среднем специальном, уровень желаемой заработной платы примерно колеблется от 20к до 60к.  
# В общем, не всегда возраст влияет на уровень желаемой заработной платы. При наличии высшего или неоконченного выысшего образования, есть оискатели желающие +100к заработную плату.

# 8. Постройте **диаграмму рассеяния**, показывающую зависимость опыта работы (**"Опыт работы (месяц)"**) от возраста (**"Возраст"**). Опыт работы переведите из месяцев в года, чтобы признаки были в едином масштабе. Постройте на графике дополнительно прямую, проходящую через точки (0, 0) и (100, 100). Данная прямая соответствует значениям, когда опыт работы равен возрасту человека. Точки, лежащие на этой прямой и выше нее - аномалии в наших данных (опыт работы больше либо равен возрасту соискателя)

# In[178]:


fig = plt.figure(figsize=(10, 5))
scatter_data = headhunter_data.copy()
scatter_data['Опыт работы (год)'] = scatter_data['Месяцы работы']/12
sns.lineplot(x=[0, 100], y=[0, 100])
ax = sns.scatterplot(
    data=scatter_data, 
    x='Возраст',
    y='Опыт работы (год)',
)
ax.set_title('Зависимость опыта работы от возраста');


# В ответе на Задание 4.8 написано 7 точк, но на графике четко видно, что точек 4 и с кривой сливаются только 2. У меня ошибка где-то в преобразованиях?  
# 
# **Выводы:** Зависимомть опыта работы от возраста линейная, но не соответствует линии проходящей через центр координат. Посколько многие люди начинают свою карьеру только в возрасте 20-30 лет. Соотвественно линейная зависимость сдвигается в сторону оси возраста.

# **Дополнительные баллы**
# 
# Для получения 2 дополнительных баллов по разведывательному анализу постройте еще два любых содержательных графика или диаграммы, которые помогут проиллюстрировать влияние признаков/взаимосвязь между признаками/распределения признаков. Приведите выводы по ним. Желательно, чтобы в анализе участвовали признаки, которые мы создавали ранее в разделе "Преобразование данных".
# 

# In[179]:


# ваш код здесь


# ваши выводы здесь

# # Очистка данных

# 1. Начнем с дубликатов в наших данных. Найдите **полные дубликаты** в таблице с резюме и удалите их. 

# In[180]:


dupl_columns = list(headhunter_data.columns)

mask = headhunter_data.duplicated(subset=dupl_columns)
headhunter_duplicates = headhunter_data[mask]
print(f'Число найденных дубликатов: {headhunter_duplicates.shape[0]}')


# In[181]:


headhunter_dedupped = headhunter_data.drop_duplicates(subset=dupl_columns)
print(f'Результирующее число записей: {headhunter_dedupped.shape[0]}')


# 2. Займемся пропусками. Выведите информацию **о числе пропусков** в столбцах. 

# In[182]:


null_data = headhunter_dedupped.isnull().sum()
display(null_data[null_data > 0])


# 3. Итак, у нас есть пропуски в 3-х столбцах: **"Опыт работы (месяц)"**, **"Последнее/нынешнее место работы"**, **"Последняя/нынешняя должность"**. Поступим следующим образом: удалите строки, где есть пропуск в столбцах с местом работы и должностью. Пропуски в столбце с опытом работы заполните **медианным** значением.

# In[183]:


#создаем копию исходной таблицы
hh_data = headhunter_dedupped.copy()

# удаляем пропуски
hh_data = hh_data.dropna(subset=['Последнее/нынешнее место работы', 'Последняя/нынешняя должность'])

#создаем словарь имя столбца: число(признак) на который надо заменить пропуски
hh_data['Месяцы работы'] = hh_data['Месяцы работы'].fillna(hh_data['Месяцы работы'].median())
print(round(hh_data['Месяцы работы'].mean()))


# 4. Мы добрались до ликвидации выбросов. Сначала очистим данные вручную. Удалите резюме, в которых указана заработная плата либо выше 1 млн. рублей, либо ниже 1 тыс. рублей.

# In[184]:


outliers = hh_data[(hh_data['ЗП (руб)'] > 1e6) | (hh_data['ЗП (руб)'] < 1000)]
hh_data = hh_data.drop(outliers.index)
print(outliers.shape[0])


# 5. В процессе разведывательного анализа мы обнаружили резюме, в которых **опыт работы в годах превышал возраст соискателя**. Найдите такие резюме и удалите их из данных
# 

# In[185]:


outliers = hh_data[hh_data['Месяцы работы']/12 >= hh_data['Возраст']]
hh_data = hh_data.drop(outliers.index)
print(outliers.shape[0])


# 6. В результате анализа мы обнаружили потенциальные выбросы в признаке **"Возраст"**. Это оказались резюме людей чересчур преклонного возраста для поиска работы. Попробуйте построить распределение признака в **логарифмическом масштабе**. Добавьте к графику линии, отображающие **среднее и границы интервала метода трех сигм**. Напомним, сделать это можно с помощью метода axvline. Например, для построение линии среднего будет иметь вид:
# 
# `histplot.axvline(log_age.mean(), color='k', lw=2)`
# 
# В какую сторону асимметрично логарифмическое распределение? Напишите об этом в комментарии к графику.
# Найдите выбросы с помощью метода z-отклонения и удалите их из данных, используйте логарифмический масштаб. Давайте сделаем послабление на **1 сигму** (возьмите 4 сигмы) в **правую сторону**.
# 
# Выведите таблицу с полученными выбросами и оцените, с каким возрастом соискатели попадают под категорию выбросов?

# In[186]:


log_age = np.log(hh_data['Возраст']+1)

fig, ax = plt.subplots(1, 1, figsize=(8, 4))

#гистограмма в логарифмическом масштабе
age_histogram = sns.histplot(log_age , bins=30, ax=ax)

age_histogram.axvline(log_age.mean(), color='k', lw=2)
age_histogram.axvline(log_age.mean()+ 4 * log_age.std(), color='k', ls='--', lw=2)
age_histogram.axvline(log_age.mean()- 3 * log_age.std(), color='k', ls='--', lw=2)

age_histogram.set_title('Логарифмическое распределение возраста');

def outliers_z_score_mod(data, feature, log_scale=False, left=3, right=3):
    if log_scale:
        x = np.log(data[feature]+1)
    else:
        x = data[feature]
    mu = x.mean()
    sigma = x.std()
    lower_bound = mu - sigma * left
    upper_bound = mu + sigma * right
    outliers = data[(x < lower_bound) | (x > upper_bound)]
    cleaned = data[(x > lower_bound) & (x < upper_bound)]
    return outliers, cleaned

outliers, cleaned = outliers_z_score_mod(hh_data, 'Возраст', log_scale=True, left=3, right = 4)
print(f'Число выбросов по методу z-отклонения: {outliers.shape[0]}')
print(f'Результирующее число записей: {cleaned.shape[0]}')

display(outliers)


#  Распределение имеет левостороннюю ассиметрию. Соискатели возрастом 15 и 100 лет попадают под категорию выбросов.

# In[ ]:




